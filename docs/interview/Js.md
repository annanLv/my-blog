# JS

## 原型和原型链
> 在Js中，每个对象都有一个属性，称为原型（prototype）

::: tip 原型链

在Js中，每个对象（包括函数）都有一个内置属性 `__proto__` ，这个属性指向创建他的函数对象的原型对象，即`prototype`属性。

当访问一个对象的属性或方法时，首先会在对象中的自身查找，如果找不到就会沿着`__proto__`属性指向的原型链向上查找，直到找到对应的属性或方法，
或者达到原型链的末尾。这种层层递进的结构形成了所谓的原型链。

:::

## 作用域与作用域链
> 作用域是静态的一块代码所在的地盘，是静态的，编写代码的时候就确定了（n+1）. 执行上下文是动态的，只有函数的时候才会产生（n+1），调用结束后就会自动释放

+ 分类：全局作用域，函数作用域，es6有了块级作用域

> 作用域链：变量取值时，先在创建该变量的作用域中找，如果没有找到，就向上级作用域找，直到查找到全局作用域，这么一个查找过程形成的作用域链就叫做作用域链

::: tip 作用

作用域可以隔绝变量，不同作用域下同名变量不会冲突

:::

## 构造函数new的过程
+ 创建一个新对象
+ 将新对象内部的 `[[Prototype]]` 属性被赋值为构造函数的 `prototype` 属性（继承构造函数的属性和方法）
+ 构造函数内部的 `this` 被赋值为这个新对象（`this`指向新对象）
+ 执行构造函数内部的代码（给新对象添加属性）
+ 如果构造函数返回对象，则返回该对象；否则，返回刚创建的新对象（空对象）

::: tip
+ 创建一个空对象
+ 构造函数内部的this指向这个空对象
+ 通过 this. 给该对象添加属性
+ 构造函数默认 return this (this就是该空对象)
:::

```js
function _new(Fn, ...args) {
    // Object.create(现有的对象)  使用现有的对象作为新对象的原型
    // 1. 新建一个对象，并将构造函数的原型作为新对象的原型，继承构造函数原型上的方法
    let obj = Object.create(Fn.prototype)
    // 2. 将构造函数的 this 指向新的对象，执行构造函数内部代码并拿到返回值
    let ref = Fn.apply(obj, args)
    // 3. 构造函数有返回则返回构造函数的返回值，没有则返回新对象obj
    return res instanceof Object ? res : obj
}
```

```js
function _new(Fn, ...args) {
    // 1. 新建一个对象
    let obj = {}
    // 2. 心对西那个的原型指针指向构造函数的原型， 继承构造函数原型上的方法
    obj.__proto__ = Fn.prototype
    // 3. 将构造函数的this指向新的对象，执行构造函数内部代码并拿到返回值
    let res = Fn.apply(obj, args)
    // 4. 构造函数有返回则返回构造函数的返回值，没有则返回新对象obj
    return res instanceof Object ? res : obj
}
```


